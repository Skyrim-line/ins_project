# 学习进度`



## 3/Mar/2024 ——<L08 React_01>



视频1:16分



## 7/Mar/2024 ——<L08 React_01>

配置react 环境，创建文件夹

![image-20240312171039593](/Users/skyrim/Library/Application Support/typora-user-images/image-20240312171039593.png)

启动react ：

`npm start`

检查当前node js 的版本

`nvm ls`

`nvm use <version>`



## 11/Mar/2024 ——<Tutorial Kevien>

视频 54:分

已看完

## 12/Mar/2024——<React 02>

* Bootstrap

安装 bootstrap:

`npm i bootstrap@3.3.7 --save`

视频： 19分

##  13/Mar/2024 ——<React 02>

* 模版语法（HTML)

* JavaScript XML 

视频1:12:00

[git如何clone所有的远程分支](https://blog.csdn.net/yuanchao99/article/details/39118439)

git clone只能clone远程库的master分支，无法clone所有分支，解决办法如下：

1. 找一个干净目录，假设是git_work
2. cd git_work
3. git clone http://myrepo.xxx.com/project/.git ,这样在git_work目录下得到一个project子目录
4. cd project
5. git branch -a，列出所有分支名称如下：
   remotes/origin/dev
   remotes/origin/release
6. git checkout -b dev origin/dev，作用是checkout远程的dev分支，在本地起名为dev分支，并切换到本地的dev分支
7. git checkout -b release origin/release，作用参见上一步解释
8. git checkout dev，切换回dev分支，并开始开发。

### 如果当前不能git push 的解决办法

要回到之前的 commit 记录并重新 push，可以使用以下步骤。注意，这会修改你的 Git 历史记录，因此要小心操作。

### 步骤1：查看历史记录
首先，查看你的 Git 历史记录，找到你想要回到的 commit。

```sh
git log
```

### 步骤2：回到指定的 commit
找到你想要回到的 commit ID，然后使用 `git checkout` 命令回到那个 commit。

```sh
git checkout <commit-id>
```

### 步骤3：创建一个新的分支（可选）
为了安全，可以创建一个新的分支来保存你回到的那个 commit。

```sh
git checkout -b <new-branch-name>
```

### 步骤4：重置当前分支到指定 commit
如果你想在当前分支上进行重置操作，可以使用 `git reset` 命令。这里有两种常见的重置方式：

- **软重置**（保留工作目录和暂存区的更改）：

  ```sh
  git reset --soft <commit-id>
  ```

- **硬重置**（完全回到指定 commit 的状态，丢弃所有更改）：

  ```sh
  git reset --hard <commit-id>
  ```

### 步骤5：强制推送到远程仓库
如果你修改了历史记录，需要强制推送到远程仓库。请谨慎使用，因为这会覆盖远程仓库的历史记录。

```sh
git push origin <branch-name> --force
```

### 示例操作流程
假设你想回到的 commit ID 是 `a1b2c3d4`，当前分支是 `main`。

```sh
# 查看历史记录，找到想要回到的 commit ID
git log

# 回到指定 commit
git checkout a1b2c3d4

# 可选：创建一个新的分支保存当前状态
git checkout -b restore-point

# 重置当前分支到指定 commit，选择适合的重置方式
git reset --hard a1b2c3d4

# 强制推送到远程仓库
git push origin main --force
```

### 注意事项
1. **强制推送**：`git push --force` 会覆盖远程仓库的历史记录，其他团队成员可能会受到影响。
2. **备份**：在执行这些操作之前，建议备份当前状态或创建一个新的分支保存当前状态。
3. **沟通**：如果你在一个团队中工作，请确保其他团队成员知道你要重写ß历史记录。

通过这些步骤，你可以回到之前的 commit 并重新 push 那次的记录。

## 8/Jun/2024--<4-18-git项目介绍>

### 用vite来配置前端环境

`$ npx create-vite@latest frontend --template react`

Vite 也是用来搭建前端的框架的

什么是**node_modules?**在配置环境的时候

Answer: npm install在自己本地的node相关的模块

**Package.lock.json**是用于控制版本号，用于存储项目的元数据和管理项目的依赖...

`package.json` 是一个在Node.js和JavaScript项目中非常重要的文件，用于存储项目的元数据和管理项目的依赖。以下是 `package.json` 文件的几个主要用途和组成部分：

1. **项目元数据**：包括项目的名称、版本、描述、作者、许可证等信息。这些信息有助于识别项目并且通常在发布到npm等包管理平台时使用。

2. **依赖管理**：`package.json` 文件列出了项目需要的依赖和开发依赖（即库和工具），这样 `npm` 或 `yarn` 这样的包管理器可以自动安装这些依赖。依赖被分为“dependencies”（项目运行所需的库）和“devDependencies”（只在开发过程中需要，比如测试库或构建工具）。

3. **脚本**：可以在 `package.json` 的 `scripts` 字段中定义脚本，这些脚本可以执行常见的任务如测试、构建和部署。通过运行 `npm run <script-name>` 可以执行这些脚本。

4. **配置**：一些工具和库可以通过 `package.json` 文件中的特定字段进行配置，这样可以集中管理项目的配置。

5. **私有性**：通过设置 `"private": true` 可以防止无意中将包发布到npm等公共注册表。

这个文件通常位于项目的根目录下，是使用Node.js或进行现代web开发的基本组成部分。

Express 后端框架：

Express 是一个灵活的 Node.js Web 应用框架，提供了一系列强大的功能帮助开发各种Web和移动应用程序。它是最流行的 Node.js 框架之一，广泛用于快速构建API和Web应用程序。以下是 Express 框架的一些主要特点：

1. **简单性**：Express 提供了非常直观和简洁的API，使得开发者可以快速地搭建服务器端逻辑。

2. **灵活性**：Express 不强加任何特定的项目结构，也不绑定任何特定的数据库或其他支持工具，这使得开发者可以自由选择最适合项目需求的工具和架构。

3. **中间件架构**：Express 的核心特性之一是其使用中间件的方式处理请求。中间件是一个函数，它可以访问请求对象（request）、响应对象（response），以及Web应用中处理请求-响应循环流程中的下一个中间件函数。这种架构使得开发者可以灵活地插入或改变请求处理逻辑。

4. **路由**：Express 允许你定义路由表用以执行不同的HTTP请求动作。这可以通过简洁的路径和方法实现，非常适合创建RESTful APIs。

5. **性能**：Express 架构简单，处理速度快，能够支持大量的并发请求，适合用来构建高性能的应用程序。

6. **生态系统**：由于Node.js和Express的普及，有大量的插件、中间件和工具可供选择，这极大地扩展了Express的功能和灵活性。

Express 通常与其他技术栈如 MongoDB 数据库和 AngularJS 或 React 前端框架一起使用，这种组合通常被称为 MEAN 或 MERN 栈。这些技术栈非常适合快速开发完整的全栈应用程序。



命令 `lsof -i tcp:8000` 将会列出所有在TCP端口8000上建立连接或监听的进程。这里的 `-i` 选项是用来指定网络连接的。

如果您确实想查询关于监听或使用特定TCP端口的信息，您可以使用以下命令：

```
bash
Copy code
lsof -i tcp:8000
```

这会告诉您哪些进程正在使用或监听TCP端口8000。

如果这不是您想要的命令或信息，请提供更多的上下文或详细描述，我可以进一步帮助您。

此命令可以查看是否和远程仓库连接上

```shell
$ git remote -v   
origin  https://github.com/Skyrim-line/ins_project.git (fetch)
origin  https://github.com/Skyrim-line/ins_project.git (push)
(base) 
```

### Git 回退到上一次的commit记录

当然，这里提供几个简单明了的终端操作示例，涉及之前提到的 `git reset` 和 `git revert` 命令。

### 1. 使用 `git reset` 回退到上一次提交

- **硬重置**（放弃工作区和暂存区的所有更改）:
  ```bash
  git reset --hard HEAD^
  ```

- **软重置**（保留工作区的更改，撤销 commit，更改保留在暂存区）:
  ```bash
  git reset --soft HEAD^
  ```

- **混合重置**（默认选项，保留工作区的更改，但是撤销 commit 和暂存区的更改）:
  ```bash
  git reset --mixed HEAD^
  ```

### 2. 使用 `git revert` 安全撤销上一次提交的更改

- **撤销最后一次提交**（并且自动创建一个新的提交）:
  ```bash
  git revert HEAD
  ```

执行这些命令后，你可以使用 `git status` 来查看当前的状态，以及 `git log` 查看提交历史，确认更改是否如预期执行。

在开发React应用程序时，`styled-components`和`react-router-dom`是两个非常流行的npm包，它们分别用于样式管理和路由管理。下面是对这两个包的详细介绍：

### 1. styled-components

`styled-components`是一个用于在React应用程序中编写CSS样式的库。它允许你将CSS样式直接附加到组件上，而不是通过传统的CSS文件。这种方法称为CSS-in-JS，它可以帮助你在JavaScript文件中封装和管理组件的样式，使样式更加模块化和可重用。使用`styled-components`，你可以创建一个样式组件，然后像使用普通React组件一样在你的应用中使用它们。

#### 示例代码：

```javascript
import styled from 'styled-components';

const Button = styled.button`
  background-color: blue;
  color: white;
  padding: 10px 20px;
  border-radius: 5px;
  border: none;
  cursor: pointer;

  &:hover {
    background-color: darkblue;
  }
`;

function App() {
  return <Button>Click me!</Button>;
}
```

在这个例子中，`Button`是一个带有特定样式的按钮组件，你可以在任何地方重用它，样式将会随组件走。

### 2. react-router-dom

`react-router-dom`是React的一个库，用于在Web应用程序中添加导航功能。它使你能够实现组件间的导航，而不会重新加载页面。这是单页应用程序(SPA)的一个基本需求。`react-router-dom`提供了多种组件（如`Router`、`Route`、`Link`等），这些组件使你能够定义应用中的路由（即URL到组件的映射）。

#### 示例代码：

```javascript
import React from 'react';
import { BrowserRouter as Router, Route, Link } from 'react-router-dom';

function Home() {
  return <h1>Home Page</h1>;
}

function About() {
  return <h1>About Page</h1>;
}

function App() {
  return (
    <Router>
      <div>
        <nav>
          <Link to="/">Home</Link>
          <Link to="/about">About</Link>
        </nav>
        <Route path="/" exact component={Home} />
        <Route path="/about" component={About} />
      </div>
    </Router>
  );
}
```

在这个例子中，`Router`组件包含应用的导航结构，`Link`组件用于创建可点击的链接，而`Route`组件则根据当前的URL决定渲染哪个组件。

这两个库在现代React开发中非常有用，提供了强大的工具集来帮助开发者构建高效且易于维护的前端应用程序。

### 在frontend/src/目录下创建了components文件夹/Profile

## 4-19 个人主页(User Profiles)



46:08

53:00

### 使用Redux来进行项目的状态管理

如果你在使用 JavaScript 或 TypeScript 编写应用程序，并且希望使用 Redux 进行状态管理，但找不到 `@reduxjs/toolkit` 这个模块，可以尝试以下几个步骤来解决问题：

1. **安装 Redux**: 首先确保你已经安装了 Redux。你可以使用 npm 或者 yarn 安装 Redux：
   ```bash
   npm install redux
   # 或者
   yarn add redux
   ```

2. **安装 Redux Toolkit**: 如果你希望使用 Redux Toolkit 提供的更方便的 API 和工具集，你需要安装 `@reduxjs/toolkit`：
   ```bash
   npm install @reduxjs/toolkit
   # 或者
   yarn add @reduxjs/toolkit
   ```

3. **检查依赖**: 确保你的项目配置正确，可以访问到 npm 或 yarn 的 registry，并且没有网络或权限问题。

4. **检查包管理器配置**: 如果你使用的是公司内部的包管理器或者私有 registry，确保你的配置允许安装 `@reduxjs/toolkit`。

5. **更新依赖**: 如果已经安装了 Redux，但是无法安装 Redux Toolkit，可以尝试更新你的依赖版本，以确保你使用的是最新的稳定版本。

通过这些步骤，你应该能够解决无法找到 `@reduxjs/toolkit` 的问题，并成功使用 Redux Toolkit 进行状态管理。

### Redux的作用

`@reduxjs/toolkit` 是 Redux 官方提供的一个工具包，旨在简化 Redux 的开发流程并提供一组约定的最佳实践。它主要包括以下几个方面的功能和优点：

1. **Redux 核心工具**: 提供了 Redux 核心 API 的封装和简化，包括 `createSlice`、`configureStore` 等，减少了样板代码的编写。

2. **约定优于配置**: Redux Toolkit 引入了一些约定，帮助开发者编写更少的代码来完成常见的 Redux 模式，如减少手动编写的 Action Types、Reducers 和 Action Creators。

3. **Immer 支持**: 使用 Immer 库来实现不可变更新的状态，使得 Reducer 编写更加简洁和直观。

4. **集成 Redux DevTools Extension**: 默认集成了 Redux DevTools Extension，提供了强大的状态管理和调试工具。

5. **默认配置的 store**: 使用 `configureStore` 可以轻松创建一个预配置的 Redux store，包括 middleware、serializers 等。

6. **性能优化**: Redux Toolkit 在内部处理了一些性能优化，如避免不必要的重新渲染和重新计算，以提升应用程序的性能表现。

总体来说，`@reduxjs/toolkit` 提供了一种更简单、更高效的方式来使用 Redux 进行状态管理，特别适合于中大型应用的开发。它旨在降低学习曲线，并且帮助开发者遵循 Redux 的最佳实践，使得代码更加清晰和易于维护。

1：18：00

**24/June/2024**

` <div key={${index}-${post.userID}}>`

- 这一行代码是在React中创建列表元素时使用的一种方法，旨在为每个元素指定一个独一无二的标识（即`key`属性）。这种标识对于React来说非常重要，因为它帮助React理解列表中哪些元素在更新时发生了变化，从而有效地进行必要的更新，而不是重建整个列表。

  ### key属性的作用
  当你在React应用中显示一组元素（比如一列帖子）时，React需要一种方式来识别每个元素的身份，以便它在数据变更后可以智能地更新界面。这就是`key`属性的作用。如果没有`key`，React可能会错乱，导致效率低下的更新，甚至错误。

  ### 代码解释
  - `<div key={`${index}-${post.userID}`}>`：这行代码中，`<div>`是一个简单的容器。`key`是它的一个特殊属性，用于告诉React这个容器在列表中的唯一标识。
  - `${index}-${post.userID}`：这里使用了模板字符串（一种在字符串中嵌入变量的方法）来构造一个独特的键。`index`是当前元素在列表中的位置编号，而`post.userID`可能是一个用户的ID。通过组合这两者，形成一个既包含位置信息也包含用户信息的唯一标识，即使列表的内容或顺序变化，React也能准确地知道每个元素的具体变动。

  ### 使用场景
  假设你正在创建一个显示用户帖子的应用，每个帖子由一个用户提交。如果只用用户ID作为`key`，而这个ID在不同帖子中可能重复，就无法确保唯一性。所以这里通过将位置索引和用户ID结合起来，形成了一个即使在多个用户提交多个帖子的情况下也能保持唯一的键。

  总之，这种做法帮助React在数据更新时，能够准确且高效地处理界面的变化，从而提升应用的性能和用户体验。

Finished 4-19

## Tutorial1-Gary

9/July/2024

.....

14/July/2024

JSX 语法：

这段语法是在 React 中用于处理输入框（或其他表单元素）变化的常见模式。让我们逐步解释它的含义和作用：

```js
onChange={(e) => setTask(e.target.value)}
```

### 解释：

- **onChange**：这是一个事件处理器属性，用于监听元素的改变事件，比如输入框内容变化时触发的 `change` 事件。

- **{(e) => setTask(e.target.value)}**：
  - `{}`：在 JSX 中，大括号 `{}` 用于表示 JavaScript 表达式。
  - `(e) => ...`：这是一个箭头函数，用来定义事件处理函数。它接收一个事件对象 `e`，该对象包含触发事件的相关信息，如 `target` 属性。
  - `e.target.value`：通过 `e.target` 可以获取触发事件的元素（这里是输入框），然后 `.value` 表示获取该元素的当前值，即用户输入的文本内容。

- **setTask**：这是一个状态更新函数，通常用于在 React 中更新状态。在上下文中，它用来更新名为 `task` 的状态变量，使其值等于输入框当前的文本内容 `e.target.value`。

### 工作原理：

- 当用户在输入框中输入或修改文本时，浏览器会触发 `onChange` 事件。
- 然后，React 会调用指定的事件处理函数 `(e) => setTask(e.target.value)`。
- 在事件处理函数内部，通过 `e.target.value` 获取用户输入的新值，并调用 `setTask` 更新 React 组件的 `task` 状态。

### 注意事项：

- React 中的状态更新是异步的，因此在调用 `setTask` 后，React 并不会立即更新组件的状态，而是将状态更新放入队列中处理。这可以提高性能并避免不必要的重复渲染。
- 使用箭头函数 `(e) => ...` 可以确保在事件处理函数内部正确引用 `e` 对象和 `setTask` 函数，而不会受到 JavaScript 中 `this` 上下文的影响。

总结来说，这种语法模式使得在 React 中实现输入框与状态之间的双向绑定变得非常简洁和直观。



双向绑定

在代码中：

```js
  const [todolist, setTools] = useState(['hello', 'world']);
  const [task, setTask] = useState('');
```

```js
const [todolist, setTodolist] = useState(['hello', 'world']);
```

- `todolist`：这是一个状态变量（State），在函数组件中通过 `useState` Hook 定义和初始化。它用来存储当前的待办事项列表，初始值为 `['hello', 'world']`。每当 `todolist` 发生变化时，React 会重新渲染组件，以反映最新的状态。
- `setTodolist`：这是一个函数，用来更新 `todolist` 的值。在 React 中，所有使用 `useState` 定义的状态变量，都会有对应的更新函数，命名规则为 `set` + 变量名的驼峰形式。通过调用 `setTodolist(newValue)`，可以更新 `todolist` 的值，并触发组件的重新渲染。

### 案例：

```javascript
<button onClick={() => {
        setTools([...todolist, task]);
        setTask('');
      }}
      >
        Add
      </button>
```

在你提供的代码中，`Add` 按钮的作用是将当前输入的任务（task）添加到待办事项列表（todolist）中，并清空输入框的内容。

让我们逐步解释 `Add` 按钮的功能及相关代码：

1. **useState Hook 的使用**：
   ```javascript
   const [todolist, setTools] = useState(['hello', 'world']);
   const [task, setTask] = useState('');
   ```
   - `todolist` 是一个状态变量，用于存储当前的待办事项列表。初始值为 `['hello', 'world']`。
   - `setTools` 是用来更新 `todolist` 状态的函数。

2. **输入框 (`<input>` 元素)**：
   ```jsx
   <input
     type="text"
     value={task}
     placeholder="Input your TODO List here"
     onChange={(e) => setTask(e.target.value)}
   />
   ```
   - 输入框的值 (`value`) 绑定到 `task` 状态，用户在输入框中输入文字时，会更新 `task` 的值。

3. **Add 按钮 (`<button>` 元素)**：
   ```jsx
   <button onClick={() => {
     setTools([...todolist, task]);
     setTask('');
   }}>
     Add
   </button>
   ```
   - 当用户点击 `Add` 按钮时，触发 `onClick` 事件。
   - 在点击事件处理函数中，首先创建一个新的数组 `([...todolist, task])`，其中包含原来的 `todolist` 的所有元素和当前的 `task`。
   - 然后调用 `setTools(newArray)` 将新的数组设置为 `todolist` 的新值，从而更新待办事项列表。
   - 最后调用 `setTask('')` 清空输入框的内容，以便用户可以继续输入新的任务。

### 总结：

`Add` 按钮的作用是根据用户在输入框中输入的内容，将新的任务添加到待办事项列表中，并确保输入框被清空，以便用户可以继续添加新的任务。这种模式通过 React 的状态管理机制，实现了输入、状态更新和界面更新的自动同步，提升了用户交互的流畅性和体验。

### React fragment

在React中，`Fragment` 是一种特殊的组件，它允许你在不添加额外节点的情况下，将多个子元素分组在一个父元素中。使用 `Fragment` 可以避免在 DOM 中额外创建不必要的节点，这对于一些需要精简 DOM 结构或者对布局有特殊要求的场景非常有用。

### 使用方法：

在 React 中，你可以使用 `Fragment` 的两种方式：

1. **使用 JSX 语法**：

   ```jsx
   import React, { Fragment } from 'react';

   function MyComponent() {
     return (
       <Fragment>
         <ChildComponent1 />
         <ChildComponent2 />
         <ChildComponent3 />
       </Fragment>
     );
   }
   ```

   或者简写形式：

   ```jsx
   function MyComponent() {
     return (
       <>
         <ChildComponent1 />
         <ChildComponent2 />
         <ChildComponent3 />
       </>
     );
   }
   ```

2. **使用 React.Fragment**：

   如果在你的文件中没有引入 `Fragment`，你可以使用 `React.Fragment`：

   ```jsx
   import React from 'react';
   
   function MyComponent() {
     return (
       <React.Fragment>
         <ChildComponent1 />
         <ChildComponent2 />
         <ChildComponent3 />
       </React.Fragment>
     );
   }
   ```

### 作用：

- **减少不必要的 DOM 节点**：使用 `Fragment` 可以避免在 DOM 结构中增加额外的 `div` 或其他元素，这在需要特别精简的 DOM 结构时非常有用。

- **不影响样式和布局**：`Fragment` 不会添加额外的节点，因此不会对样式和布局产生影响。

- **逻辑组织**：将相关的子组件组织在一个逻辑单元中，提升代码的可读性和维护性。

总结来说，`Fragment` 是 React 中的一个工具，用于组合多个子元素而不引入额外的 DOM 节点，使得代码更加清晰和高效。



## Node.js (1) 2-7基础知识介绍

14/July/2024

**ES module（ESM）和 CommonJS module** 

这是两种 JavaScript 模块化的标准和实现方式，它们有一些显著的区别和特点：

### ES module (ESM)

1. **语法**：
   - 使用 `import` 和 `export` 关键字来导入和导出模块。
   - 导入：`import { something } from 'module'`
   - 导出：`export { something }`

2. **异步加载**：
   - 支持异步加载模块，可以动态地导入模块。
   - 示例：
     ```javascript
     import('./module.js').then(module => {
       // 使用 module
     }).catch(error => {
       // 处理错误
     });
     ```

3. **静态解析**：
   - 模块的依赖关系在编译时静态解析，有利于工具进行静态分析和优化。

4. **作用域**：
   - 模块的作用域是静态的，模块内部的变量不会暴露到全局作用域。

5. **浏览器兼容性**：
   - 现代浏览器和 Node.js 12+ 支持 ES module。

6. **默认导出**：
   - 支持默认导出和命名导出。

### CommonJS module (CJS)

1. **语法**：
   - 使用 `require()` 函数来引入模块。
   - 导入：`const something = require('module')`
   - 导出：`module.exports = something`

2. **同步加载**：
   - 采用同步加载模块的方式，不支持动态导入。

3. **动态模块路径**：
   - 可以使用动态计算的模块路径，例如 `require('./' + fileName)`。

4. **作用域**：
   - 模块的作用域是运行时动态确定的，模块内部变量可能会污染全局作用域。

5. **浏览器兼容性**：
   - 浏览器不原生支持 CommonJS 模块，需要使用打包工具（如 Browserify 或 webpack）进行转换。

6. **默认导出**：
   - 只支持默认导出，不支持命名导出。

**主要区别总结：**

- **语法和导入方式**：ES module 使用 `import/export`，CommonJS 使用 `require/module.exports`。
- **加载方式**：ES module 支持异步加载和静态解析，CommonJS 是同步加载和动态解析。
- **作用域**：ES module 的作用域是静态的，不会污染全局作用域；CommonJS 的作用域是运行时动态确定的，可能会影响全局作用域。
- **浏览器兼容性**：ES module 直接在现代浏览器中支持，CommonJS 需要通过工具转换才能在浏览器中使用。

在 Node.js 中，默认的模块系统是 CommonJS，但是 Node.js 也支持 ES module，可以通过文件扩展名 `.mjs` 或者在 `package.json` 中指定 `"type": "module"` 来启用 ES module。

### charAt(xxx)

在你提供的代码中，`.charAt()` 是一个 JavaScript 字符串方法，用于获取字符串中指定位置的字符。

### 解释代码：

```javascript
const lines = content.split('\n'); // 使用换行符分割文本内容，得到一个行数组
console.log('Lines:', lines); // 打印分割后的行数组
const initials = lines.map(line => {
    const words = line.split(' '); // 使用空格分割每一行，得到一个单词数组
    const firstLetters = words.map(word => word.charAt(0)); // 获取每个单词的第一个字母组成的数组
    return firstLetters.join(''); // 将数组中的字母连接成一个字符串
});
```

### `.charAt()` 方法：

- `.charAt()` 方法用于获取字符串中指定位置（索引）的字符。
- 索引从 0 开始，即字符串的第一个字符索引为 0，第二个为 1，依此类推。
- 如果指定的索引超出了字符串的长度，则返回一个空字符串 `''`。
- 例如，`word.charAt(0)` 就是获取字符串 `word` 的第一个字符。

### 示例：

假设有一个字符串：

```javascript
const word = "Hello";
const firstLetter = word.charAt(0); // 获取第一个字符
console.log(firstLetter); // 输出 "H"
```

在你的代码中，`word.charAt(0)` 被用来获取每个单词 `word` 的第一个字母，然后将这些字母组成一个新的字符串，最终构成了 `initials` 数组中的每个元素。

完成这个视频node.js的学习



## Node.js Express.js

Aug 23 2024

完成该视频的学习

## Tutorial2-Gray

Aug 31 2024

react 相关的tut在INS-CLONE文件夹里的tut目录下

学习到34 :00

完成本视频学习



## Node.js -RESTFUL-API

Sep 4

完成该视频的学习



## Tutorial-3--Gray

24:00

Sep 9  完成



## Node.js - User-Authenticate

Sep 5 

53:00

Sep 16 完成该视频的学习，并写好Login,Register,Home 三个页面，熟悉了React开发的整个架构
